# Architecture of App
The server side architecture of any web application is critical to ensure that the web app is stable under different
loads and is able to generate the data in a method that is responsive, and reliable. In addition, any private user
data must be secured, and the app should protect itself against malicious attacks.

## Working Within the Play Framework
The Play framework provides a robust system for developing server applications in Java and Scala. The framework
uses Scala internally as well as in Twirl, the HTML templating language. The Play framework has been designed to 
support many of the critical details around routing, and server stability so that developers can focus more on functionality.

In this app, we made use of a few of Play's features
* Guice Dependency Injection
* Testing Databuilders
* Twirl HTML templates
* Auto publishing for production
* Templated request routing

The app was designed to carefully adhere to Model-View-Controller (MVC) principles in the class design and functionality.

The model package primarily contains `Controller` subclasses. These classes provide the functionality to respond to HTTP
events and provide an appropriate response to the client. Controllers are primarily defined by the methods they contain.
Controller classes are instantiated to hold private fields that cannot be static. These dependencies are injected by
Guice and are used to provide information to the response methods. Some examples of injected objects are
* FormFactory: The Play factory for handling form input for a given data class
* MessagesApi: Used to pass error messages between parts of the application
* WhaleModel: The singleton model of the Observations and Whales

Using injection is very powerful in these situations because the Play framework can manage the lifecycle of objects as
they are required and dependencies can be modified for a production or testing situation.

The controllers are responsible for the business logic of the application. They handle the input of the request and
either render content or perform actions to modify the model. In our case we have developed five controller classes to
contain different groupings of tasks.

* `Driver`: Handle basic rendering of static pages
* `ObservationController`: Handle requests related to creating and displaying observations
* `SearchController`: Handle the filtering of data based on search queries
* `WhaleAPIController`: Handle converting Whale data to JSON and responding appropriately
* `WhaleController`: Handle actions for adding and deleting whales as well as managing content negotiation between JSON for the API and HTML for browsers.

These controllers are usually clear in their function but require the most error handling because they react to external inputs
which cannot be easily controlled.

The only exception to `Controller`s in the controllers package are the `SearchData`, `ObservationData`, and `WhaleData` objects.
The classes are used for form generation. Similar to data access objects in databases, these temporary objects hold
data until it can be verified as accurate. One of the primary reasons for this is the separation of the abstraction in the 
model, and the annotation involved in validating external data. When a form is completed, Jackson is used to parse the form
into the object. If this process fails, then the Model has not been impacted in any way. Once the objects have been
verified as valid, they can be entered into the model. The forms themselves fall into the views of the Play library.

All the files in the views package are Twirl, Scala/HTML, files. These files are primarily responsible for rendering
the information stored in the model and requested by the controller into a usable interface for consumption.
There are numerous templates for different interface elements. In order to make the site as composable as possible,
UI blocks were separated into smaller pieces so that they could be used on multiple pages. The consistent look and feel
of the site is achieved by making every page ultimately render `htmlHeader.scala.html` with the content section
being passed as a constructor parameter. Using Scala functional interfaces meant that it is easy to make repeated data.
As an example of this, the table of whales is generated by flat mapping observations and whales into tuples which can
then be mapped into a Twirl template which uses the appropriate file to render the information.

Writing unit tests was heavily supported by using Guice and the Play frameworks' data builders. The RequestBuilder made
the creation of specific headers and related testing data like form submissions much easier. While writing the unit tests
we wanted to ensure that each controller works as expected under a range of conditions. For many test cases the pattern
involved cleaning out the model to make tests independent, assembling the model in a known way, invoking a request
that modified the model, verify that the model ended in the right state and that the content matched expectations.
Testing the controllers that manipulate the model was critical to ensure that happened correctly if the UI responds how
it is designed to do. This helped us differentiate bugs in the front and back end when features were not working as expected.

Making Routes was one of the nicest features of the Play framework. By templating parameters like the observation id from
url requests before the controllers were called greatly simplified the hassle of extracting data from uris directly.
The ROUTES were used wherever possible so that if we changed the actual url all of our forms would update automatically.

Logging all requests and model interactions was also performed as an important part of monitoring the remote app.
One of the few diagnostic tools available from the public site is the ability to read log files out of the app. SJF4J gives a reliable
way to operate logging. We had two log streams. "requests" and WhaleModel.class. On the requests stream, the result
that was being returned to the user was logged at an info level. Any response other than a 404 which is handled internally
is not in error, even in the case of error handling. The WhaleModel stream had more varied levels. If the user performs
an operation successfully on the model, this is recorded as debug. Likely this information will not be considered.
Any time that a model action could not be performed this is recorded as a warn. The system is not failing and the user
will not experience and error but the action has had no meaningful effect. Any exceptions caught in try/catches are logged
at an error level.

## Developing the Model
One of the important parts of this project was to build a model that could capture the required pieces of information
(Gender, Weight, Species) and be extensible to separate the data from the method of storing it. The central class is
`WhaleModel`. This class contains a reference to an ObservationStore and a WhaleStore. In our case, a single class
`SimpleHashStore` implements both interfaces. We chose to have two interfaces instead of one to more easily capture the
table based behaviour of a database. Guice could be used to map the database to the relevant interfaces where `SimpleHasStore`
is used presently.

An Observation consists of a time, a location and a set of whales. The time is stored as a `LocalDateTime` to better capture 
some complexity of different users entering information in different timezones. The location is stored as a string. We
wanted to integrate the Google Maps API, but did not have enough time to do so. A string can store the relevant information,
but can be harder to filter in data analysis. The collection of whales was chosen to be a set for two primary reasons.
1) It doesn't make conceptual sense for any whale to be observed twice at the same time. The set imposes a natural restriction
on the physical phenomenon. 2) When updating whales in the model, the same action can used for creating or updating. This
   simplifies the logic of the model greatly.
   
Whales contain an estimated weight, gender, species and id. In order to ensure a unique id for comparing whales,
a static Long counter keeps track of the total number of whale objects instantiated and assigns them an id on creation.
The weight is stored as an int. The largest recorded whales are about 200,000 kg so an int is sufficient. This value is
required to be greater than 0. This is enforced in the `WhaleData` object. Both `Gender` and `Species` are enums. The
primary reason for this is to ensure that inputs conform to standard options and that graphics can be associated with them.

## Challenges
There were a number of challenges involved in using the Play framework. One of the first was getting accustomed to using
a system where the thread of execution is not clear. Play handles compilation, and running, so we needed to become accustomed
to the workflow and using Guice to provide classes that we needed. A secondary challenge involved using Scala. Many of
the Java types and data can be easily called in Scala or mapped 1-to-1. Some things did, for example making `Seq` objects
for the drop down menus meant we needed to write one Scala object `FormUtils` for converting lists to `Seq`.

Writing unit tests was also challenging. Most of the specifications for valid input, for example for the date format,
were dictated by the HTML standard, so we could not write tests before we had implemented the front end very easily. 
Once we had them working, we were able to verify the behaviour of the system outputs. An interesting challenge that we
resolved because of testing was using a static model. Initially, we made WhaleModel a static singleton. However, as
soon we began writing tests we observed unsurprising issues with flakiness due to concurrent tests operating on the model
at the same time. We were also tripped up by the fact that SBT does not support JUnit5 which we were all used to.

Posting the app to a public server on Heroku was not too hard, but it was challenging to ensure that it was
operating properly initially to set up the git repository and make sure that we all the required configuration to install
the right version of Java etc.

## Future Work
While we are pleased with the progress of the Whale Watcher, there are many things that we would like to add. The most
obvious is a database for permanent data persistence. We did try out using H2 but due to inexperience with SQL queries
we decided that it was more important to focus on a reliable UI rather than sinking more time into a DB. We have
constructed the model so that it should be rapid to substitute the systems in and out for each other. 

We want to expand the API. Currently, only the GET /whales endpoint exists for reading all whales but adding additional
actions for adding whales, and observations is not a significant undertaking. In many ways ensuring that the specifications
that we publish accurately match the operation of the system is just as critical. The ROUTES templating of Play will
enhance this by auto-extracting get parameters and passing them into the controllers. 

There are two other larger features that a system like this should have. First is user authentication. Because anyone
has equal rights to create and delete whales, and observations the leaves important data exposed. Creating and deleting
records should be limited to Scientists (Admins) and those who created the record. The second thing we would like to add
is the ability to upload images of sightings. This information would be quite useful to scientists later and would allow
for some analysis to be moved from users without training to people who could extract additional context from raw data.
